"""
A thief robbing a store finds n items. The i-th item is worth v_i dollars and
weighs w_i pounds, where v_i and w_i are integers. The thief wants to take as
valuable a load as possible, but he can carry at most W pounds in his knapsack,
 for some integer W. Which items should he take?
"""
import enum

import unittest

# No value
_NO_V = 0

# No weight
_NO_W = 0

class _Option(enum.Enum):
    """
    Provides constants to explore options during optima selection
    """
    FIRST = 1
    SECOND = 2
    THIRD = 3

def _get_index(first, last, total):
    """
    Provides compact index for given subset of items

    Parameters
    ----------
    first, last : int
        Indexes of the first and last items of a subset

    total : int
        Total number of items

    Returns
    -------
    int
        An index
    """
    assert first <= last < total
    return int(first * (2 * total - first - 1) / 2 + last)

def _get_compact_storage_size(total):
    """
    Provides total size of a compact storage to serve given number of items
  
    Parameters
    ----------
    total : int
        Total number of items

    Returns
    -------
    int
        Size
    """
    return int(total * (total + 1) / 2)

def _arrange_trio_by_value(firstValue, secondValue, thirdValue):
    """
    Compares values of given subproblems and arranges them from the most
    valuable to the least one

    Parameters
    ----------
    firstValue, secondValue, thirdValue : int
        Value of the first, second and third subproblems

    Yields
    -------
    _Option
        Tag of the next most valuable item
    """
    if firstValue < secondValue:
        if secondValue < thirdValue:
            yield _Option.THIRD
            yield _Option.SECOND
            yield _Option.FIRST
        else:
            yield _Option.SECOND

            if firstValue < thirdValue:
                yield _Option.THIRD
                yield _Option.FIRST
            else:
                yield _Option.FIRST
                yield _Option.THIRD
    else:
        if firstValue < thirdValue:
            yield _Option.THIRD
            yield _Option.FIRST
            yield _Option.SECOND
        else:
            yield _Option.FIRST

            if secondValue < thirdValue:
                yield _Option.THIRD
                yield _Option.SECOND
            else:
                yield _Option.SECOND
                yield _Option.THIRD

def _is_within(weight, capacity):
    """
    Checks whether given weight is within capacity of knapsack

    Parameters
    ----------
    weight : int
        Weight of a subproblem

    capacity : int 
        Capacity of a knapsack

    Returns
    -------
    bool
        True if weight fits capacity
    """
    if _NO_W == weight:
        return False
    return weight <= capacity

def _evaluate_and_pick_two_subproblems(priorValue, bidderValue, nextValue,
                                       priorWeight, bidderWeight, nextWeight, capacity,
                                       priorBounds, b, nextBounds):
    """
    Evaluates all combinations of 2 of 3 subproblems generated by a bidder

    Parameters
    ----------
    priorValue, bidderValue, nextValue : int
        Profits of subproblems

    priorWeight, bidderWeight, nextWeight : int
        Weights of subproblems

    capacity : int
        Capacity of knapsack

    priorBounds, nextBounds : [(int, int)]
        Bounds of subproblems adjacent to the bidder

    b : int
        Id of the bidder item

    Returns
    -------
    [(int, int), ...], int, int
        Structure of optima, its value and weight
    """
    optionOptima, optionValue, optionWeight = [], _NO_V, _NO_W

    firstValue = priorValue + _NO_V + nextValue
    secondValue = _NO_V + bidderValue + nextValue
    thirdValue = priorValue + bidderValue + _NO_V
    for tag in _arrange_trio_by_value(firstValue, secondValue, thirdValue):
        if _Option.FIRST == tag:
            weight = priorWeight + _NO_W + nextWeight
            if _is_within(weight, capacity):
                optionOptima = priorBounds + [] + nextBounds
                optionValue, optionWeight = firstValue, weight
                break
        elif _Option.SECOND == tag:
            weight = _NO_W + bidderWeight + nextWeight
            if _is_within(weight, capacity):
                optionOptima = [] + [(b, b)] + nextBounds
                optionValue, optionWeight = secondValue, weight
                break
        elif _Option.THIRD == tag:
            weight = priorWeight + bidderWeight + _NO_W
            if _is_within(weight, capacity):
                optionOptima = priorBounds + [(b, b)] + []
                optionValue, optionWeight = thirdValue, weight
                break
        else:
            assert False

    return optionOptima, optionValue, optionWeight

def _evaluate_and_pick_one_subproblem(priorValue, bidderValue, nextValue,
                                      priorWeight, bidderWeight, nextWeight, capacity,
                                      priorBounds, b, nextBounds):
    """
    Evaluates all single subproblems generated by a bidder

    Parameters
    ----------
    priorValue, bidderValue, nextValue : int
        Profits of subproblems

    priorWeight, bidderWeight, nextWeight : int
        Weights of subproblems

    capacity : int
        Capacity of knapsack

    priorBounds, nextBounds : [(int, int)]
        Bounds of subproblems adjacent to the bidder

    b : int
        Id of the bidder item

    Returns
    -------
    [(int, int)], int, int
        Structure of optima, its value and weight
    """
    optionOptima, optionValue, optionWeight = [], _NO_V, _NO_W

    firstValue = priorValue + _NO_V + _NO_V
    secondValue = _NO_V + bidderValue + _NO_V
    thirdValue = _NO_V + _NO_V + nextValue
    for tag in _arrange_trio_by_value(firstValue, secondValue, thirdValue):
        if _Option.FIRST == tag:
            weight = priorWeight + _NO_W + _NO_W
            if _is_within(weight, capacity):
                optionOptima = priorBounds + [] + []
                optionValue, optionWeight = firstValue, weight
                break
        elif _Option.SECOND == tag:
            weight = _NO_W + bidderWeight + _NO_W
            if _is_within(weight, capacity):
                optionOptima = [] + [(b, b)] + []
                optionValue, optionWeight = secondValue, weight
                break
        elif _Option.THIRD == tag:
            weight = _NO_W + _NO_W + nextWeight
            if _is_within(weight, capacity):
                optionOptima = [] + [] + nextBounds
                optionValue, optionWeight = thirdValue, weight
                break
        else:
            assert False

    return optionOptima, optionValue, optionWeight

def _construct_optimas(stock, capacity):
    """
    Constructs optimas for all subproblems of given problem to solve

    Parameters
    ----------
    stock : list of (int, int)
        Value and weight of i-th item

    capacity : int
        Capacity of a knapsack

    Returns
    -------
    [[(int, int), ...], ...]
        Decompositions of each subproblem into smaller one
    """
    t = len(stock)
    
    storageSize = _get_compact_storage_size(t)
    # optimas[i, j] shows from which, even smaller subproblems, an optimal solution for the ij-subproblem
    # should be composed
    # The maximum number of subproblems is 3(an item, plus solution for the prior items, and for the next)
    # The minimum - 0, for the case when all items exceed capacity of the knapsack
    optimas = [[]] * storageSize
    # profits[i, j] is robber's profit and weight to carry, if only i-th though j-th items are allowed
    # to be selected from
    subStocks = [(_NO_V, _NO_W)] * storageSize
    
    # Inspect each subproblem size from just single item up to them all
    for d in range(t):
        # Inspect subproblems starting from i-th item up to selected size
        for f in range(t - d):
            l = f + d
            optima = []
            subStock = _NO_V, _NO_W
            # Study an option to include each separate element of the subproblem, so that profit is maximized
            for b in range(f, l + 1):
                # Pick solution for the prior subproblem, if any
                priorBounds = []
                priorValue, priorWeight = _NO_V, _NO_W
                if b != f:
                    priorBounds = [(f, b - 1)]
                    ind = _get_index(f, b - 1, t)
                    priorValue, priorWeight = subStocks[ind]
    
                # Pick solution for the next subproblem, if any
                nextBounds = []
                nextValue, nextWeight = _NO_V, _NO_W
                if b != l:
                    nextBounds = [(b + 1, l)]
                    ind = _get_index(b + 1, l, t)
                    nextValue, nextWeight = subStocks[ind]
    
                # Pick value and weight of the bidder item
                bidderValue, bidderWeight = stock[b]
    
                # Examine all, 2^3, options to combine the subproblems to fulfill weight requirements,
                # while maximizing profit
                optionOptima = []
                optionValue, optionWeight = _NO_V, _NO_W
    
                weights = priorWeight + bidderWeight + nextWeight
                if weights <= capacity:
                    optionOptima = priorBounds + [(b, b)] + nextBounds
                    optionValue = priorValue + bidderValue + nextValue
                    optionWeight = weights
                else:
                    optionOptima, optionValue, optionWeight =\
                        _evaluate_and_pick_two_subproblems(priorValue, bidderValue, nextValue,
                                                           priorWeight, bidderWeight, nextWeight, capacity,
                                                           priorBounds, b, nextBounds)
                    if not optionOptima:
                        assert optionValue == _NO_V
                        assert optionWeight == _NO_W
                        optionOptima, optionValue, optionWeight =\
                            _evaluate_and_pick_one_subproblem(priorValue, bidderValue, nextValue,
                                                              priorWeight, bidderWeight, nextWeight, capacity,
                                                              priorBounds, b, nextBounds)
    
                # Update local optimal solution, if bidder improves it
                if subStock[0] <= optionValue:
                    optima = optionOptima
                    assert optionWeight <= capacity
                    subStock = optionValue, optionWeight
    
            # Memorize optima for the subproblem
            ind = _get_index(f, l, t)
            optimas[ind] = optima
            subStocks[ind] = subStock

    return optimas

def _extract_items_to_pick(optimas, t):
    """
    Reconstructs set of items to pick from given decomposition

    Parameters
    ----------
    optimas : [[(int, int), ...], ...]
        Decompositions of each subproblem into smaller one

    Returns
    -------
    [int, ...]
        Ids of items to pick
    """
    optima = []

    if not optimas:
        assert t == 0
        return optima
    
    queue = []
    ind = _get_index(0, t - 1, t)
    queue.extend(optimas[ind])
    while queue:
        f, l = queue.pop(0)
        if f == l:
            optima.append(f)
            continue
        ind = _get_index(f, l, t)
        queue.extend(optimas[ind])
    
    return sorted(optima)

def solve_zero_one_knapsack_problem(stock, capacity):
    """
    Implements a dynamic-programming solution to the 0-1 knapsack problem.

    Parameters
    ----------
    stock : [(int, int), ...]
        Value and weight of i-th item

    capacity : int
        Capacity of a knapsack

    Returns
    -------
    [int, ...]
        Indexes of items to pick for a perfect robbery
    """
    for s in stock:
        v, w = s
        if v <= 0:
            raise ValueError('Value of item #' + str(stock.index((v, w))) + ' is not reasonable')
        if w <= 0:
            raise ValueError('Weight of item #' + str(stock.index((v, w))) + ' is not reasonable')

    optimas = _construct_optimas(stock, capacity)

    t = len(stock)
    optima = _extract_items_to_pick(optimas, t)

    return optima

class Tests(unittest.TestCase):
    def setUp(self):
        self.stock162 = [(60, 10), (100, 20), (120, 30)]
        self.capacity162 = 50
        self.best162 = [[1, 2]]

        self.stockNoIntermAtOpt = [(1, 2), (2, 6), (1, 3)]
        self.capacityNoIntermAtOpt = 5
        self.bestNoIntermAtOpt = [[0, 2]]

        self.stockIntermToSkip = [(2, 1), (2, 2), (4, 3), (3, 2), (6, 5), (2, 1)]
        self.capacityIntermToSkip = 5
        self.bestIntermToSkip = [[0, 1, 3]]

        self.stockTinyKnapsack = [(10, 3), (27, 2), (93, 4)]
        self.capacityTinyKnapsack = 1
        self.bestTinyKnapsack = [[]]

        self.stockTinyKnapsackForBoth = [(56, 4), (90, 7)]
        self.capacityTinyKnapsackForBoth = 3
        self.bestTinyKnapsackForBoth = [[]]

        self.stockTinyKnapsackForOne = [(65, 5)]
        self.capacityTinyKnapsackForOne = 4
        self.bestTinyKnapsackForOne = [[]]

        self.stockNothingToTake = []
        self.capacityNothingToTake = 5
        self.bestNothingToTake = [[]]

        self.stockPerfectGlove = [(20, 3), (50, 5), (70, 6)]
        self.capacityPerfectGlove = 5
        self.bestPerfectGlove = [[1]]

        self.stockPerfectGloveConf = [(10, 3), (30, 3), (24, 3)]
        self.capacityPerfectGloveConf = 3
        self.bestPerfectGloveConf = [[1]]

        self.stockGrabItAll = [(12, 5), (45, 9), (145, 7), (98, 1), (67, 3), (32, 5)]
        self.capacityGrabItAll = 10000
        self.bestGrabItAll = [[0, 1, 2, 3, 4, 5]]

        self.stockIllegalWeight = [(20, 0)]
        self.capacityIllegalWeight = 10

        self.stockIllegalValue = [(-5, 3)]
        self.capacityIllegalValue = 5 

    def test_16_2(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stock162,
                                                      capacity = self.capacity162),
                      self.best162)

    def test_no_intermidiates_at_optimal(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockNoIntermAtOpt,
                                                      capacity = self.capacityNoIntermAtOpt),
                      self.bestNoIntermAtOpt)

    def test_intermidiates_to_skip(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockIntermToSkip,
                                                      capacity = self.capacityIntermToSkip),
                      self.bestIntermToSkip)

    def test_tiny_knapsack(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockTinyKnapsack,
                                                      capacity = self.capacityTinyKnapsack),
                      self.bestTinyKnapsack)

    def test_tiny_knapsack_for_both(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockTinyKnapsackForBoth,
                                                      capacity = self.capacityTinyKnapsackForBoth),
                      self.bestTinyKnapsackForBoth)

    def test_tiny_knapsack_for_one(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockTinyKnapsackForOne,
                                                      capacity = self.capacityTinyKnapsackForOne),
                      self.bestTinyKnapsackForOne)

    def test_nothing_to_take(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockNothingToTake,
                                                      capacity = self.capacityNothingToTake),
                      self.bestNothingToTake)

    def test_perfect_glove(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockPerfectGlove,
                                                      capacity = self.capacityPerfectGlove),
                      self.bestPerfectGlove)

    def test_perfect_glove_conflicting(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockPerfectGloveConf,
                                                      capacity = self.capacityPerfectGloveConf),
                      self.bestPerfectGloveConf)

    def test_grab_it_all(self):
        self.assertIn(solve_zero_one_knapsack_problem(stock = self.stockGrabItAll,
                                                      capacity = self.capacityGrabItAll),
                      self.bestGrabItAll)

    def test_illegal_weight(self):
        self.assertRaises(ValueError,
                          solve_zero_one_knapsack_problem,
                          stock = self.stockIllegalWeight, capacity = self.capacityIllegalWeight)

    def test_illegal_value(self):
        self.assertRaises(ValueError,
                          solve_zero_one_knapsack_problem,
                          stock = self.stockIllegalValue,
                          capacity = self.capacityIllegalValue)

if __name__ == '__main__':
    unittest.main()